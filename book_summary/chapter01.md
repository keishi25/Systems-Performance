# Chapter 01: システムパフォーマンスに必要なプロセス

## 概要
本章では、システムパフォーマンスを測定・改善するために必要な一連のプロセスを整理する。  
ソフトウェアのライフサイクルに沿って「どのような作業が必要か」、また「可視化のための手法（トレーシング・実験）」について理解する。  

## 目的
- パフォーマンスエンジニアリングで必要な作業をライフサイクル全体で把握する  
- トレーシング手法（静的・動的・BPF）の違いを理解し、使い分けられるようにする  
- 実験（ベンチマーク）を通じてシステムの挙動や限界を理解する  

---

## 1.3 作業

システムパフォーマンスに関する作業は多岐にわたる。  
ソフトウェアプロジェクトのライフサイクルに沿って、以下のような作業が発生する：

1. 将来のプロダクトのパフォーマンス目標を設定し、パフォーマンスモデルを作成する。  
2. ソフトウェアアーキテクチャやコードに関わるパフォーマンス特性を定める。  
3. テスト環境で開発中のプロダクトのパフォーマンスを評価する。  
4. プロダクトの新バージョンのために非回帰テストを行う。  
5. 本番リリースへのデプロイ前にパフォーマンステストを行う。  
6. 対象の本番環境でPoC（概念実証）テストを行う。  
7. 本番環境でパフォーマンスをチューニングする。  
8. 本番環境で稼働中のソフトウェアをモニタリングする。  
9. 本番環境で発生した障害を分析する。  
10. 本番環境でのパフォーマンス障害のインシデント評価を行う。  
11. 本番環境の分析を強化するためのパフォーマンスツールを開発する。  

---

## 1.7.3 トレーシング

**目的**  
イベントベースの記録を収集し、システムの動作やプロセスの関連性を可視化する。  

**代表例**  
Linux では `strace`, `tcpdump`, `Ftrace`, `BCC`, `bpftrace` など。  

トレーシングには大きく2種類ある：  

- 静的インストルメンテーション (static instrumentation)  
- 動的インストルメンテーション (dynamic instrumentation)  

---

### 1.7.3.1 静的インストルメンテーション
- ソースコードに予めトレースポイントを仕込んでおく方法。  
- Linux カーネルでは **tracepoint**、ライブラリでは **USDT (User Statically Defined Tracing)** と呼ばれる。  
- **例**：`execsnoop` → `execve()` システムコールをトレースして、SSH ログインなどの実行プロセスを観察可能。  

---

### 1.7.3.2 動的インストルメンテーション
- 実行中のソフトウェアに動的に命令を挿入してトレーシングする。  
- 静的に仕込まれていないポイントでも観察できる柔軟性がある。  
- Linux では `dynamickernel tracer`, `kprobes`、Solaris では **DTrace** が有名。  

**利点**  
- 自由度が高く、未知の問題に対応可能  

**欠点**  
- パフォーマンスコストや複雑さが増す場合がある  

---

### 1.7.3.3 BPF (Berkeley Packet Filter)
- 元々はパケットキャプチャのための仕組み。  
- 2013年頃から拡張され、**eBPF (extended BPF)** が登場。  
- Linux カーネルに仮想マシンを組み込み、小さなプログラムを実行できるようにした。  
- トレーシングに強力に利用されるようになり、`BCC (BPF Compiler Collection)` や `bpftrace` などが登場。  
- `execsnoop` のような BPF ベースツールは、軽量かつ強力な可視化手段を提供。  

---

## 1.8 実験 (Experimentation)

- パフォーマンスエンジニアリングにおいて **実験** も重要な可視化手法。  
- **マイクロベンチマーク (micro-benchmark)** と **マクロベンチマーク (macro-benchmark)** がある。  

**マイクロ**  
- CPU, ディスクI/O, メモリといった要素単位の測定  

**マクロ**  
- システム全体のワークロードを対象にした測定  

実験により「実際に負荷を与えてどう性能が変わるか」を把握できる。  

**例**  
- `iperf` を用いたネットワークスループット測定  

---

## 可視化手法の比較表

| 手法                                              | 特徴                           | メリット                                       | デメリット                          | 代表ツール / 例                                     | 向いている場面                        |
| ------------------------------------------------- | ------------------------------ | ---------------------------------------------- | ----------------------------------- | --------------------------------------------------- | ------------------------------------- |
| **静的インストルメンテーション**<br>(Static Instrumentation)  | ソースやバイナリにあらかじめトレースポイントを仕込む   | ・オーバーヘッドが小さい<br>・安定して再利用できる                | ・仕込んだ箇所しか見られない<br>・事前準備が必要     | tracepoints (Linux kernel), USDT, `execsnoop` | よく使う処理の継続的な監視、再現性が重要な場合        |
| **動的インストルメンテーション**<br>(Dynamic Instrumentation) | 実行中のプロセスに命令を挿入して観察           | ・柔軟に任意の箇所を観測できる<br>・未知の問題に対応可能             | ・オーバーヘッドが大きい場合あり<br>・不安定になるリスク | kprobes, SystemTap, DTrace                        | 事前に仕込んでいない未知の問題の調査             |
| **BPF / eBPF**                                    | カーネルに組み込まれた仮想マシンで小さなプログラムを実行 | ・柔軟かつ安全にカーネル空間を観測<br>・高パフォーマンス<br>・豊富なツール群 | ・比較的新しいため習得コストあり               | BCC, bpftrace, `execsnoop` (BPF版)                 | 高度なトレーシング、ネットワーク/システム全体の軽量な可視化 |
| **実験 (Experimentation)**                        | 実際に負荷をかけて性能を測定する             | ・理論でなく実際の挙動を把握できる<br>・システム全体の特性がわかる        | ・本番に近い環境が必要<br>・リスク（負荷による影響）あり | iperf, micro-benchmarks, macro-benchmarks         | ネットワーク帯域確認、CPU/メモリ/ディスクの限界測定   |

---

## 使い分けの目安

- **日常的なモニタリング** → 静的インストルメンテーション  
- **未知のトラブル調査** → 動的インストルメンテーション  
- **軽量で安全に詳細分析** → BPF/eBPF  
- **システム全体の挙動や限界確認** → 実験（ベンチマーク）  
