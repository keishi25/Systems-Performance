# Chapter 01: システムパフォーマンスに必要なプロセス

## 概要
本章では、システムパフォーマンスを測定・改善するために必要な一連のプロセスを整理する。  
ソフトウェアのライフサイクルに沿って「どのような作業が必要か」、また「可視化のための手法（トレーシング・実験）」について理解する。  

## 目的
- パフォーマンスエンジニアリングで必要な作業をライフサイクル全体で把握する  
- トレーシング手法（静的・動的・BPF）の違いを理解し、使い分けられるようにする  
- 実験（ベンチマーク）を通じてシステムの挙動や限界を理解する  

---

## 1.3 作業

システムパフォーマンスに関する作業は多岐にわたる。  
ソフトウェアプロジェクトのライフサイクルに沿って、以下のような作業が発生する：

1. 将来のプロダクトのパフォーマンス目標を設定し、パフォーマンスモデルを作成する。  
2. ソフトウェアアーキテクチャやコードに関わるパフォーマンス特性を定める。  
3. テスト環境で開発中のプロダクトのパフォーマンスを評価する。  
4. プロダクトの新バージョンのために非回帰テストを行う。  
5. 本番リリースへのデプロイ前にパフォーマンステストを行う。  
6. 対象の本番環境でPoC（概念実証）テストを行う。  
7. 本番環境でパフォーマンスをチューニングする。  
8. 本番環境で稼働中のソフトウェアをモニタリングする。  
9. 本番環境で発生した障害を分析する。  
10. 本番環境でのパフォーマンス障害のインシデント評価を行う。  
11. 本番環境の分析を強化するためのパフォーマンスツールを開発する。  

---

## 1.7.3 トレーシング

**目的**  
イベントベースの記録を収集し、システムの動作やプロセスの関連性を可視化する。  
OSに限らずアプリケーションにも適用できる

**代表例**  
Linux では `strace`, `tcpdump`, `Ftrace`, `BCC`, `bpftrace` など。  


トレーシングには大きく2種類ある：  

- 静的インストルメンテーション (static instrumentation)  
- 動的インストルメンテーション (dynamic instrumentation)  

---

### 1.7.3.1 静的インストルメンテーション
- ソースコードに予めトレースポイントを仕込んでおく方法。  
- Linux カーネルでは **tracepoint**、ライブラリでは **USDT (User Statically Defined Tracing)** と呼ばれる。  
- **例**：`execsnoop` → `execve()` システムコールをトレースして、SSH ログインなどの実行プロセスを観察可能。  
実例、OSにbpftraceをinstallする。
```bash
sudo apt install bpftrace
```
mysqlのソースコードにUSDT マクロを仕込むで、ビルドする。
```
#include <sys/sdt.h>   // USDT のヘッダ

void mysql_execute_query(const char *query) {
    DTRACE_PROBE(mysql, query__start);   // クエリ開始を通知

    // 実際のクエリ実行処理
    execute(query);

    DTRACE_PROBE(mysql, query__done);    // クエリ終了を通知
}

```

- DTRACE_PROBE(mysql, query__start)
→ 「mysql:query__start」というイベントを発火するトレースポイント。

- DTRACE_PROBE(mysql, query__done)
→ 「mysql:query__done」というイベントを発火。


#### ✅ 観測の流れ

1. MySQL バイナリに USDT が埋め込まれている  
2. MySQL がクエリを実行すると、そのトレースポイントが発火する  
3. OS 上で `bpftrace` がそれをキャッチして出力する  

---

#### ✅ まとめ

- **埋め込むのは MySQL 開発者**（ソースコードに仕込む）  
- **利用するのは MySQL ユーザ**（`bpftrace` などで外から観測する）  
- MySQL ユーザは「USDT がすでに入っているか確認し、必要なら `bpftrace` で使う」だけでよい  

**例：クエリ開始イベントを観測**
```bash
sudo bpftrace -e 'usdt:/usr/sbin/mysqld:query__start { printf("Query started\n"); }'
```

ちなみに、ログ（general log, Error log等）やPerfomance Schemaとは別。
| 手法                                              | 取得できる情報                       | 特徴                                 | メリット                                                         | デメリット                                    | 主な利用シーン                       |
| ----------------------------------------------- | ----------------------------- | ---------------------------------- | ------------------------------------------------------------ | ---------------------------------------- | ----------------------------- |
| **ログ (General Log, Slow Query Log, Error Log)** | 実行されたクエリ全文、エラー、スロークエリ         | MySQL 内部でファイルやテーブルに記録              | ・設定だけで簡単に有効化できる<br>・SQL をそのまま確認可能                            | ・I/O 負荷が大きい<br>・大量トラフィック環境では現実的でない       | 開発・検証環境での調査、トラブル発生時の一時的利用     |
| **Performance Schema**                          | クエリ実行時間、待機イベント、ロック、メモリ使用量など   | MySQL 内部のテーブルに統計情報を蓄積              | ・詳細な統計を取得可能<br>・SQL で柔軟に分析できる                                | ・設定とクエリのチューニングが必要<br>・細かすぎて運用が複雑化することも   | 本番環境での継続的なパフォーマンス監視           |
| **USDT (User Statically Defined Tracing)**      | クエリ開始/終了、ロック待ち開始/終了など（外部から取得） | MySQL バイナリに埋め込まれたトレースポイントを外部ツールで利用 | ・外部から非侵襲的に観測可能<br>・無効時オーバーヘッドほぼゼロ<br>・bpftrace/dtrace で柔軟に解析 | ・使えるイベントはあらかじめ埋め込まれたものに限られる<br>・ツール習熟が必要 | 本番環境での軽量トラブルシューティング、SRE による調査 |


---

### 1.7.3.2 動的インストルメンテーション
- 実行中のソフトウェアに動的に命令を挿入してトレーシングする。  
- 静的に仕込まれていないポイントでも観察できる柔軟性がある。  
- Linux では `dynamickernel tracer`, `kprobes`、Solaris では **DTrace** が有名。  

**利点**  
- 自由度が高く、未知の問題に対応可能  

**欠点**  
- パフォーマンスコストや複雑さが増す場合がある  

---

### 1.7.3.3 BPF (Berkeley Packet Filter)
- 元々はパケットキャプチャのための仕組み。  
- 2013年頃から拡張され、**eBPF (extended BPF)** が登場。  
- Linux カーネルに仮想マシンを組み込み、小さなプログラムを実行できるようにした。  
- トレーシングに強力に利用されるようになり、`BCC (BPF Compiler Collection)` や `bpftrace` などが登場。  
- `execsnoop` のような BPF ベースツールは、軽量かつ強力な可視化手段を提供。  

---

## 1.8 実験 (Experimentation)

- パフォーマンスエンジニアリングにおいて **実験** も重要な可視化手法。  
- **マイクロベンチマーク (micro-benchmark)** と **マクロベンチマーク (macro-benchmark)** がある。  

**マイクロ**  
- CPU, ディスクI/O, メモリといった要素単位の測定  

**マクロ**  
- システム全体のワークロードを対象にした測定  

実験により「実際に負荷を与えてどう性能が変わるか」を把握できる。  

**例**  
- `iperf` を用いたネットワークスループット測定  

---

## 可視化手法の比較表

| 手法                                              | 特徴                           | メリット                                       | デメリット                          | 代表ツール / 例                                     | 向いている場面                        |
| ------------------------------------------------- | ------------------------------ | ---------------------------------------------- | ----------------------------------- | --------------------------------------------------- | ------------------------------------- |
| **静的インストルメンテーション**<br>(Static Instrumentation)  | ソースやバイナリにあらかじめトレースポイントを仕込む   | ・オーバーヘッドが小さい<br>・安定して再利用できる                | ・仕込んだ箇所しか見られない<br>・事前準備が必要     | tracepoints (Linux kernel), USDT, `execsnoop` | よく使う処理の継続的な監視、再現性が重要な場合        |
| **動的インストルメンテーション**<br>(Dynamic Instrumentation) | 実行中のプロセスに命令を挿入して観察           | ・柔軟に任意の箇所を観測できる<br>・未知の問題に対応可能             | ・オーバーヘッドが大きい場合あり<br>・不安定になるリスク | kprobes, SystemTap, DTrace                        | 事前に仕込んでいない未知の問題の調査             |
| **BPF / eBPF**                                    | カーネルに組み込まれた仮想マシンで小さなプログラムを実行 | ・柔軟かつ安全にカーネル空間を観測<br>・高パフォーマンス<br>・豊富なツール群 | ・比較的新しいため習得コストあり               | BCC, bpftrace, `execsnoop` (BPF版)                 | 高度なトレーシング、ネットワーク/システム全体の軽量な可視化 |
| **実験 (Experimentation)**                        | 実際に負荷をかけて性能を測定する             | ・理論でなく実際の挙動を把握できる<br>・システム全体の特性がわかる        | ・本番に近い環境が必要<br>・リスク（負荷による影響）あり | iperf, micro-benchmarks, macro-benchmarks         | ネットワーク帯域確認、CPU/メモリ/ディスクの限界測定   |

---

## 使い分けの目安

- **日常的なモニタリング** → 静的インストルメンテーション  
- **未知のトラブル調査** → 動的インストルメンテーション  
- **軽量で安全に詳細分析** → BPF/eBPF  
- **システム全体の挙動や限界確認** → 実験（ベンチマーク）  
